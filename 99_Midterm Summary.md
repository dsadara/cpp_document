# Section2 (출력)

## namespace

- 함수 클래스들을 하나로 뭉침, 이름 충돌 방지 가능

## 조정자

1. showpos noshowpos : \+ 출력
2. dec hex oct
3. uppercase nouppercase
4. showbase noshowbase : 진법표기
5. left internal right
6. showpoint noshowpoint : 소수점 이하 표기
7. fixed scientific
8. boolalpha noboolalpha

### iomanip 조정자

1. setw() : 컬럼 수 설정
2. setfill() : 빈 컬럼 문자 설정
3. setprecision() : 표현 자리수

#### cout 멤버 메서드

1. setf() : 조정자 플래그 세트
2. width() : 컬럼 수 설정

# Section4 (일부 새로운 C++ 기능)

- 값에 의한 호출 : 복사본이 들어가 원본 변경불가능
- 참조에 의한 호출 : 참조를 전달해 원본 변경 가능

## 참조

- 포인터의 안전한 형태
- 변수에 별칭을 붙여주는 역할
- NULL이 될 수 없음
- 초기화 중 반드시 대입 나중에 참조 대상 못 바꿈

### 출력결과 매개변수

- 출력결과용 매개변수는 포인터로
  - \& 로 구분이 됨
  ```c++
  TryDivide(&a, b, c);
  ```
- 읽기전용 매개변수는 const 참조로

# Section7 (개체지향 프로그래밍1)

## OOP란?

- 사람이 세상을 바라보는 방식
  - 물체는 **상태**와 **행동**으로 나눌 수 있음
  - 상태는 변수, 행동은 함수
- 클래스는 객체의 blueprint
  - 인스턴스화 : 클래스를 객체로

## 접근 제어자(Access Modifier)

- C++의 기본 접근권한은 private
- public : 누구나 접근 가능
- protected : 자식 클래스에서 접근 가능
- private : 해당 클래스에서만 접근 가능
- C++ 클래스 헤더에서의 접근 제어자 순서
  - public 그 다음에 private를 보여준다
    - 클래스의 사용법을 볼 때 보통 헤더를 보는데 이 때 내가 사용할 수 있는 public 부분을 주로 보기 때문에 위에 위치함
    - Java는 이의 반대로 클래스 제작자의 편의성을 위해 private이 위에 있음

## 스택, 힙

- c++은 스택 또는 힙에서 개체생성이 가능

### 스택

- 컴파일 옵션으로 미리 예약된 로컬 메모리 공간
- 함수의 호출과 반환이 이 메모리에서 일어남
  - 함수가 호출과 반환이 될 때마다 스택 포인터가 움직이는 구조
  - 이때문에 메모리 할당 및 해제가 필요 없음
    - 스택 메모리가 빠른 이유
- 성능이 느려지는 경우
  - 하드웨어에 스왑 파일을 불러올 때 느려진다

### 힙

- 컴파일시 정하는 메모리 공간이 아닌 OS가 제공하는 방대한 메모리 공간
- 원하는 크기의 비어 있는 메모리를 찾기 위해 힙 메모리 전체를 둘러봐야 해서 느리다
- 프로그래머가 직접 할당 및 해제
  - 해제 안하면 메모리 누수

### 힙과 스택 선택시 고려사항

- 스택을 쓰면 좋은 경우
  - 오브젝트의 크기가 충분히 작으면 스택을 쓰는게 좋음
- 힙을 쓰면 좋은 경우
  - 오브젝트의 크기가 큰 경우, 실행중에 새로 개체를 만드는 경우가 많을 때, 오브젝트를 복사할 일이 많을 때(다른 함수에 전달할 일이 많을 때, 오브젝트를 반환할 때)

### RAII(Resource Acquisition is Initialization) 원칙

- new 한 함수가 그 개체를 지워줘야 한다는 원칙
- new한 개체를 반환하면 호출자는 그것을 delete해야할지 안할지 모름
- Factory 패턴은 이가 적용되지 않음

## 개체 배열

- 개체 배열
  ```c++
  Vector* list = new Vector[10];
  ```
  - 스택 메모리에 첫번쨰 개체를 가리키는 포인터 한 개, 힙 메모리에 Vector 개체 10개를 만들어 줌
- 벡터 포인터 배열
  ```c++
  Vector** list = new Vector*[10];
  ```
  - 스택 메모리에 첫번째 개체 포인터를 가리키는 포인터 한 개, 힙 메모리에 Vector를 가리키는 포인터 10개를 만들어 줌
- 개체 배열 삭제 시 대괄호\(\[\]\)를 꼭 붙일 것
  - 개체 포인터 배열을 개별 포인터들도 delete 해줘야 함

## 초기화 리스트(Initializer List)

- 오브젝트가 만들어 질 때 멤버를 초기화하는 방법
  - 선언과 동시에 초기화 해야 하는 상수 변수와 참조 변수를 초기화할 수 있음

## 생성자(Constructor)

### 기본 생성자

- 매개변수를 받지 않는 생성자
- 생성자를 정의 안하면 컴파일러가 자동으로 만들어 줌
  - 멤버 변수를 초기화 안해주고, 포함된 개체의 생성자만 호출해 줌

## 생성자 오버로딩

- 매개변수가 다른 여러 가지의 생성자를 만드는 것

## 소멸자

- 개체가 지워질 때 호출됨
- 동적으로 할당한 메모리를 직접 해제해 줘야 함
- 소멸자는 오버로딩 없음
  - 매개변수가 없는 하나의 형태로만 존재

## const 멤버 함수

- 해당 개체 안의 어떠한 것도 바꿀 수 없음

## 구조체 vs 클래스

- c++에서 구조체는 클래스와 동일한 개념
  - 차이점은 기본 접근 권한이 다름(접근 제어자를 안 썼을 때의 접근 제어자)
    - 클래스는 private 구조체는 public
- 구조체 권장 사용법
  - C 스타일 처럼 plain old data만 포함하는게 좋다
    - 메모리 카피를 가능하게 하기 위해

# Section8 (개체지향 프로그래밍2)

## 복사 생성자

- 같은 클래스에 속한 다른 개체를 이용하여 새로운 개체를 초기화
- 암시적 복사생성자는 얕은 복사를 수행
  - 멤버의 값을 복사함, 개체 멤버는 그 개체의 복사 생성자 호출
  - 멤버에 참조나 클래스가 있으면 복사 생성자를 직접 만들어 깊은 복사 수행하자

## 함수 오버로딩

- 같은 이름의 메소드를 중복하여 정의
  - 반환형은 중복이 안 된다 매개변수가 같고 반환형이 다르면 컴파일 에러

## 연산자 오버로딩

- 하나의 연산자를 피연산자가 다르면 다른 동작을 해줌
- chaining을 위하여 반환값을 lhs의 참조형태로 반환을 해줌
- 연산자만 보고 어떤 함수인지 유추하기 힘들면 연산자가 아닌 차라리 함수로 만들자

### 멤버 함수 연산자 오버로딩

- lhs가 개체인 경우 개체의 멤버인 연산자 오버로딩 함수를 호출해 줌

### 전역 함수 연산자 오버로딩

- lhs가 접근할 수 없는 클래스인 경우 전역 함수로 연산자 오버로딩 함수를 만듦
- 매개변수 rhs에 접근하기 위해서 전역함수를 rhs 클래스에 넣고 friend를 붙이면 rhs 클래스의 멤버에 접근 가능
  - 전역함수의 구현체는 rhs 클래스 cpp 파일에 넣어주는게 좋음

## friend

- 다른 클래스나 함수가 나의 private또는 protected 멤버에 접근하게 허용함
- friend 클래스 : 다른 namespace의 클래스가 해당 클래스의 멤버에 접근 가능하게 함
- friend 함수 : 클래스 바깥의 함수에 private 접근 권한을 줌
- getter와 setter은 같은 패키지(네임스페이스) 안 모든 클래스가 이에 접근이 가능하지만 friend를 사용하면 특정 클래스만 접근 가능하게 함

## 연산자 오버로딩과 const

- 어디에나 const를 붙일 것
  - 함수, 매개변수, 지역변수
  - 멤버 변수의 값이 바뀌는것을 방지하기 위해
- 대입 함수는 lhs를 바꿔야 하므로 함수에 const를 붙이지 않는다

### 매개변수로 const &를 사용하는 이유

- 매개변수 전달 시 불필요한 복사가 필요 없음
- 멤버 변수 변경 방지
- 매개변수로 &를 사용하면 함수 호출 시 스택 메모리를 조금 덜 쓰게 된다
  - 개체가 복사되는 대신 주소가 스택에 올라가므로

## 암시적 함수들

- 클래스에 기본으로 생기는 암시적 함수들
  - 매개변수 없는 생성자, 복사 생성자, 소멸자, 대입 연산자
- 암시적 대입 연산자
  - 얕은 복사로 멤버들에 값 복사함

## 암시적 함수들 제거법

- private에 암시적 함수들을 넣어서 외부에서 호출을 못하게 하면 된다
  - 기본 생성자, 복사 생성자, 소멸자, 대입 연산자

# Section9 (개체지향 프로그래밍3)

## 상속

- 다른 클래스의 특성들을 내려 받음
- 베이스 클래스, 파생 클래스
- public 상속 : 부모의 public 멤버 public으로 접근가능 나머지는 그대로
- private 상속 : 모든 멤버를 private로맘ㄴ 접근 가능
- protected 상속 : public 멤버는 protected로 private멤버는 private로
- 부모의 메모리가 앞에 위치함 : 부모 포인터 사용 자식 저장 가능, 부모의 생성자가 먼저 호출되는 이유임

## 다형성

함수 오버라이딩을 이용해 부모 클래스의 함수가 자식 클래스에서 여러 모습으로 변화

### 함수 오버라이딩 : 부모의 함수를 자식 클래스에서 재구현

멤버 함수는 사실 객체를 매개변수로 전달하는 전역 함수랑 다르지 않음

### 정적 바인딩

부모 포인터가 자식을 담고 있는 경우 오버라이드 함수를 호출할 때 부모의 것을 호출, 무늬를 따라 가는 것, 컴파일 시 호출할 함수가 결정되어 빠르다

### 동적 바인딩

오버라이드 함수를 호출할 때 자식의 것을 호출, 실체 따라 가는 것, 가상 함수를 사용, 실행 중에 객체의 함수 주소를 찾어 느리다

### 가상 함수

자식 클래스가 함수를 구현할 것이라고 기대하는 함수, 자식 클래스의 오버라이딩 함수가 언제나 호출 됨, 이를 위해 객체에 가상 테이블 주소 포함

### 가상 소멸자

부모 포인터가 자식을 담고 있는 경우 가상테이블을 이용해서 자식의 소멸자를 먼저 호출시켜줌, 자식 소멸자를 호출 안하는 메모리 누수 방지

## 추상 함수

?

## 추상 소멸자

?

## 추상 클래스

- 순수 가상함수를 가지고 있는 베이스 클래스
- 순수 가상함수는 부모는 선언만 하고 구현체가 자식에 있는 함수
- 순수 추상 클래스는 데이터가 없고 순수 가상 함수만 가지고 있는 클래스

## 생성자 순서

부모의 생성자가 먼저 호출되고 자식의 생성자가 호출된다

## 소멸자 순서

자식의 소멸자가 먼저 호출되고 자동으로 부모의 소멸자가 호출된다

# Section10 (캐스팅)

- 암시적 캐스팅 : 명시적으로 캐스팅을 안했을 경우 프로그래머 형 변환
- 명시적 캐스팅 : 프로그래머가 형 변한을 위한 코드를 직접 작성

## static_cast

1. 값을 유지하면서 두 숫자형 타입간의 변환
   - 비트패턴은 바뀔수도 있음, 반올림 오차가 발생할 수도 있음
2. 베이스 클래스 포인터에서 파생 클래스 포인터로 변환
   - 컴파일 시 상속관계를 확인함, 크래시가 날 수 있다

## reinterpret_cast

- 비트 패턴을 유지하면서 형 변환
  - 연관 없는 두 포인터 형 사이의 변환 가능
  - 포인터와 비포인터 변수 사이 형 변환 가능
- 예상치 못한 값으로 변할 수 있어 위험함
  - 포인터의 주소를 int로 출력하고 싶을때만 사용

## const_cast

- const를 제거하는 캐스팅, 타입은 바꿀 수 없다
- 외부 라이브러리에서 const를 제대로 사용 안했을 때 사용

## dynamic_Cast

- 포인터 또는 참조형을 실행중에 캐스팅
  - 호환되지 않는 자식형으로 캐스팅 하려 하면 NULL을 반환한다
- 실행 중에 실시간으로 타입정보를 이용해 캐스팅 함
  - 컴파일 시 RTTI 가 켜져 있어야 됨
  - RTTI가 꺼져 있으면 static_cast로 동작

# Section11 (인라인 함수)

## 인라인 함수

- 단순한 연산을 가진 함수를 호출 대신 복사 붙여넣기 하여 함수호출의 오버헤드를 줄이는 방법
- 매크로 함수와 차이점은 컴파일 시 수행된다는 점 그리고 멤버의 접근권한을 체크함
- 주의할 점은 함수 구현이 \#include 되는 헤더 파일에 위치해야 하는 점임 컴파일 과정에서는 \.cpp파일에 뭐가 들어 있는지 모른다
