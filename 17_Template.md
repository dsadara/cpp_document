# 템플릿(template)이란?

템플릿은 컴파일 시 템플릿 매개변수 타입에 대한 함수나 클래스를 생성해주는 기능입니다.
즉 하나의 함수 또는 클래스만 작성해도 여러 타입의 함수 또는 클래스를 자동으로 생성해주는 **일반화**기능입니다.
정확한 정의는 [다음 글]()에서 살펴 볼테니 이 글에서는 화살괄호 \<\>가 있는 것이 템플릿이라고 알아두면 됩니다. 
Java나 C#의 제네릭(generic) 메서드/클래스가 C++의 템플릿과 비슷합니다.


## 대표적인 템플릿 사용 예 

아래 코드는 템플릿을 대표적으로 사용하는 [벡터]입니다.
벡터는 템플릿으로 작성되어 어떤 타입이든 동작합니다. 

```c++
// Main.cpp
#include <vector>

int main()
{
    std::vector<int> scores;
    scores.push_back(10);
    scores.push_back(50);

    return 0;
}
```   

# 템플릿의 사용처?

## 코드를 자료형마다 중복으로 작성해야 할 때
예를들어 두 정수를 더하는 함수가 있다고 합시다.

```c++
int Add(int a, int b)
{
    return a + b;
}
```

만약에 두 실수를 더하고 싶다면 double이나 float에 대한 Add()함수를 추가로 작성해야 합니다.   
템플릿 함수를 작성하면 그럴 필요 없이 Add() 한 개만 작성하면 됩니다.

```c++
// MyMath.h
// 템플릿 함수
template <typename T>   // 또는 template <class T>
T Add(T a, T b)
{
    return a + b;
}

// Main.cpp
int main()
{
    std::cout << Add<int>(3, 10) << std::endl;      // 정수에 대한 add()함수
    std::cout << Add<float>(3.14f, 10.14f) << std::endl;    // 실수에 대한 add() 함수

    return 0;
}
```

컴파일러가 int와 float에 대한 함수를 자동으로 만들어줍니다.

## 템플릿 메타 프로그래밍
템플릿을 이용한 트릭도 있습니다.
실행 시 돌리면 느린 함수들을 컴파일 시 미리 돌려놓아 함수의 결과값을 미리 평가(evaluate) 해 놓은 다음
실행 시 이를 상수로 사용할 수 있습니다.
예를 들어 템플릿을 재귀함수와 같이 동작하게 하여 컴파일 시 재귀 결과값을 구할 수 있습니다.
하지만 템플릿 메타 프로그래밍은 가독성이 안 좋고 컴파일 시간이 길어진다는 단점을 가집니다.
자세한 내용은 [템플릿 메타프로그래밍]()을 참고하시면 됩니다.

## 정적 다형성
[다형성]()은 런타임 중에 어떤 형이냐에 따라 행동이 달라지는 거였습니다.
템플릿을 사용하면 컴파일중에 다형성의 동작을 할 수 있습니다.
런타임 중 동작하는 다형성은 가상함수에서 한 번 점프를 해야 해서 조금 느렸었는데 이를 빠르게 할 수 있습니다. 
그리고 자식 클래스마다 다른 함수를 작성할 필요 없이 템플릿 함수 하나만 작성해주면 되므로 편리합니다. 
이를 [정적 다형성](https://wikidocs.net/494) 이라고 합니다. 
하지만 동적 다형성처럼 객체 모둠을 한번에 처리할 수는 없습니다. 이는 정적 다형성의 한계입니다.
예를 들어 아래와 같은 처리를 하지 못합니다.
```c++

```

# 템플릿은 어떻게 작동할까?

다음의 코드를 봅시다.

```c++
// MyMath.h
template <typename T>
T Add(T a, T b)
{
    return a + b;
}
```
```c++
// Main.cpp
#inclue "MyMath.h"

int main()
{
    int resultInt = Add<int>(3, 10);   // int형으로 템플릿 인스턴스화
    float resultFloat = Add<float>(3.14f, 10.14f);   // float형으로 템플릿 인스턴스화

    return 0;
}
```

템플릿을 인스턴스화할 때마다 컴파일러가 내부적으로 다음과 같은 코드를 생성합니다.
여기서 템플릿 인스턴스란 템플릿 매개변수 타입에 대한 함수를 생성하는 것을 말합니다. 

```c++
// Main.cpp
#inclue "MyMath.h"

// 컴파일러가 추가한 코드 
int Add(int a, int b) 
{
    return a + b;
}
// 컴파일러가 추가한 코드 
float Add(float a, float b)
{
    return a + b;
}


int main()
{
    int resultInt = Add<int>(3, 10);   // int형으로 템플릿 인스턴스화
    float resultFloat = Add<float>(3.14f, 10.14f);   // float형으로 템플릿 인스턴스화

    return 0;
}
```

만약에 100개가 넘는 타입을 템플릿 인스턴스화 하면 어떨까요?
컴파일러가 100개만큼 함수를 생성할 것이고 그만큼 코드가 길어질 것입니다.
코드가 길어지면 exe 파일 크기가 증가하고, 컴파일 시간이 느려지는 문제들이 생깁니다. 


# 현재 템플릿 현황은 어떨까?

템플릿이 나온 이후 사람들이 최적화를 명목으로 많이 남용을 했지만,
가독성이 떨어지거나 컴파일 시간이 길어진다는 문제점들이 생겨 사용이 줄어드는 추세였고,
C+11 이후에 [constexpr]()이라는 것이 나오면서 요즘은 정말 필요한 곳에만 템플릿이 사용이 됩니다.  