# Section2

## namespace

- 함수 클래스들을 하나로 뭉침, 이름 충돌 방지 가능

## 조정자

1. showpos noshowpos : \+ 출력
2. dec hex oct
3. uppercase nouppercase
4. showbase noshowbase : 진법표기
5. left internal right
6. showpoint noshowpoint : 소수점 이하 표기
7. fixed scientific
8. boolalpha noboolalpha

### iomanip 조정자

1. setw() : 컬럼 수 설정
2. setfill() : 빈 컬럼 문자 설정
3. setprecision() : 표현 자리수

#### cout 멤버 메서드

1. setf() : 조정자 플래그 세트
2. width() : 컬럼 수 설정

# Section4

- 값에 의한 호출 : 복사본이 들어가 원본 변경불가능
- 참조에 의한 호출 : 참조를 전달해 원본 변경 가능

## 참조

- 포인터의 안전한 형태
- 변수에 별칭을 붙여주는 역할
- NULL이 될 수 없음
- 초기화 중 반드시 대입 나중에 참조 대상 못 바꿈

### 출력결과 매개변수

- 출력결과용 매개변수는 포인터로
  - \& 로 구분이 됨
  ```c++
  TryDivide(&a, b, c);
  ```
- 읽기전용 매개변수는 const 참조로

# Section9

## 상속

- 다른 클래스의 특성들을 내려 받음
- 베이스 클래스, 파생 클래스
- public 상속 : 부모의 public 멤버 public으로 접근가능 나머지는 그대로
- private 상속 : 모든 멤버를 private로맘ㄴ 접근 가능
- protected 상속 : public 멤버는 protected로 private멤버는 private로
- 부모의 메모리가 앞에 위치함 : 부모 포인터 사용 자식 저장 가능, 부모의 생성자가 먼저 호출되는 이유임

## 다형성

함수 오버라이딩을 이용해 부모 클래스의 함수가 자식 클래스에서 여러 모습으로 변화

### 함수 오버라이딩 : 부모의 함수를 자식 클래스에서 재구현

멤버 함수는 사실 객체를 매개변수로 전달하는 전역 함수랑 다르지 않음

### 정적 바인딩

부모 포인터가 자식을 담고 있는 경우 오버라이드 함수를 호출할 때 부모의 것을 호출, 무늬를 따라 가는 것, 컴파일 시 호출할 함수가 결정되어 빠르다

### 동적 바인딩

오버라이드 함수를 호출할 때 자식의 것을 호출, 실체 따라 가는 것, 가상 함수를 사용, 실행 중에 객체의 함수 주소를 찾어 느리다

### 가상 함수

자식 클래스가 함수를 구현할 것이라고 기대하는 함수, 자식 클래스의 오버라이딩 함수가 언제나 호출 됨, 이를 위해 객체에 가상 테이블 주소 포함

### 가상 소멸자

부모 포인터가 자식을 담고 있는 경우 가상테이블을 이용해서 자식의 소멸자를 먼저 호출시켜줌, 자식 소멸자를 호출 안하는 메모리 누수 방지

## 추상 함수

?

## 추상 소멸자

?

## 추상 클래스

- 순수 가상함수를 가지고 있는 베이스 클래스
- 순수 가상함수는 부모는 선언만 하고 구현체가 자식에 있는 함수
- 순수 추상 클래스는 데이터가 없고 순수 가상 함수만 가지고 있는 클래스

## 생성자 순서

부모의 생성자가 먼저 호출되고 자식의 생성자가 호출된다

## 소멸자 순서

자식의 소멸자가 먼저 호출되고 자동으로 부모의 소멸자가 호출된다

# Section10 (캐스팅)

- 암시적 캐스팅 : 명시적으로 캐스팅을 안했을 경우 프로그래머 형 변환
- 명시적 캐스팅 : 프로그래머가 형 변한을 위한 코드를 직접 작성

## static_cast

1. 값을 유지하면서 두 숫자형 타입간의 변환
   - 비트패턴은 바뀔수도 있음, 반올림 오차가 발생할 수도 있음
2. 베이스 클래스 포인터에서 파생 클래스 포인터로 변환
   - 컴파일 시 상속관계를 확인함, 크래시가 날 수 있다

## reinterpret_cast

- 비트 패턴을 유지하면서 형 변환
  - 연관 없는 두 포인터 형 사이의 변환 가능
  - 포인터와 비포인터 변수 사이 형 변환 가능
- 예상치 못한 값으로 변할 수 있어 위험함
  - 포인터의 주소를 int로 출력하고 싶을때만 사용

## const_cast

- const를 제거하는 캐스팅, 타입은 바꿀 수 없다
- 외부 라이브러리에서 const를 제대로 사용 안했을 때 사용

## dynamic_Cast

- 포인터 또는 참조형을 실행중에 캐스팅
  - 호환되지 않는 자식형으로 캐스팅 하려 하면 NULL을 반환한다
- 실행 중에 실시간으로 타입정보를 이용해 캐스팅 함
  - 컴파일 시 RTTI 가 켜져 있어야 됨
  - RTTI가 꺼져 있으면 static_cast로 동작

# Section11 (인라인 함수)

## 인라인 함수

- 단순한 연산을 가진 함수를 호출 대신 복사 붙여넣기 하여 함수호출의 오버헤드를 줄이는 방법
- 매크로 함수와 차이점은 컴파일 시 수행된다는 점 그리고 멤버의 접근권한을 체크함
- 주의할 점은 함수 구현이 \#include 되는 헤더 파일에 위치해야 하는 점임 컴파일 과정에서는 \.cpp파일에 뭐가 들어 있는지 모른다
