# Section2

## namespace

- 함수 클래스들을 하나로 뭉침, 이름 충돌 방지 가능

## 조정자

1. showpos noshowpos : \+ 출력
2. dec hex oct
3. uppercase nouppercase
4. showbase noshowbase : 진법표기
5. left internal right
6. showpoint noshowpoint : 소수점 이하 표기
7. fixed scientific
8. boolalpha noboolalpha

### iomanip 조정자

1. setw() : 컬럼 수 설정
2. setfill() : 빈 컬럼 문자 설정
3. setprecision() : 표현 자리수

#### cout 멤버 메서드

1. setf() : 조정자 플래그 세트
2. width() : 컬럼 수 설정

# Section4

- 값에 의한 호출 : 복사본이 들어가 원본 변경불가능
- 참조에 의한 호출 : 참조를 전달해 원본 변경 가능

## 참조

- 포인터의 안전한 형태
- 변수에 별칭을 붙여주는 역할
- NULL이 될 수 없음
- 초기화 중 반드시 대입 나중에 참조 대상 못 바꿈

### 출력결과 매개변수

- 출력결과용 매개변수는 포인터로
  - \& 로 구분이 됨
  ```c++
  TryDivide(&a, b, c);
  ```
- 읽기전용 매개변수는 const 참조로

# Section9

## 상속

- 다른 클래스의 특성들을 내려 받음
- 베이스 클래스, 파생 클래스
- public 상속 : 부모의 public 멤버 public으로 접근가능 나머지는 그대로
- private 상속 : 모든 멤버를 private로맘ㄴ 접근 가능
- protected 상속 : public 멤버는 protected로 private멤버는 private로
- 부모의 메모리가 앞에 위치함 : 부모 포인터 사용 자식 저장 가능, 부모의 생성자가 먼저 호출되는 이유임

## 다형성

함수 오버라이딩을 이용해 부모 클래스의 함수가 자식 클래스에서 여러 모습으로 변화

### 함수 오버라이딩 : 부모의 함수를 자식 클래스에서 재구현

멤버 함수는 사실 객체를 매개변수로 전달하는 전역 함수랑 다르지 않음

### 정적 바인딩 

부모 포인터가 자식을 담고 있는 경우 오버라이드 함수를 호출할 때 부모의 것을 호출, 무늬를 따라 가는 것, 컴파일 시 호출할 함수가 결정되어 빠르다

### 동적 바인딩

오버라이드 함수를 호출할 때 자식의 것을 호출, 실체 따라 가는 것, 가상 함수를 사용, 실행 중에 객체의 함수 주소를 찾어 느리다

### 가상 함수

자식 클래스가 함수를 구현할 것이라고 기대하는 함수, 자식 클래스의 오버라이딩 함수가 언제나 호출 됨, 이를 위해 객체에 가상 테이블 주소 포함

### 가상 소멸자

부모 포인터가 자식을 담고 있는 경우 가상테이블을 이용해서 자식의 소멸자를 먼저 호출시켜줌, 자식 소멸자를 호출 안하는 메모리 누수 방지

## 추상 함수
?

## 추상 소멸자
?

## 추상 클래스

- 순수 가상함수를 가지고 있는 베이스 클래스
- 순수 가상함수는 부모는 선언만 하고 구현체가 자식에 있는 함수
- 순수 추상 클래스는 데이터가 없고 순수 가상 함수만 가지고 있는 클래스

## 생성자 순서

부모의 생성자가 먼저 호출되고 자식의 생성자가 호출된다

## 소멸자 순서

자식의 소멸자가 먼저 호출되고 자동으로 부모의 소멸자가 호출된다
