# Section7:개체지향 프로그래밍1

> 중간고사 대비 주제
>
> 1. 접근 제어자(Access Modifier)
## 1. OOP란?
### 1.1. C++에서의 OOP vs Java에서의 OOP 
* C++, Java에 공통적으로 존재하는 OOP요소
  * 클래스, 개체, 생성자, 함수 오버로딩, 힙에 개체 생성하기  
* C++에만 존재하는 OOP요소
  * 스택에 개체 생성하기, 복사 생성자, 소멸자, 연산자 오버로딩
* C++에서는 OOP와 OOP 아닌 것을 섞어 쓸 수 있음
  * C와의 후방호환성을 가짐
* C++은 언매니지드 언어
  * Java와 달리 메모리를 직접 관리해준다
### 1.2. OOP가 뭘까?
* 사람이 세상을 바라보는 방식
  *  사람이 바라보는 물체는 '상태'와 '행동'으로 나눌 수 있음
    ![image](https://user-images.githubusercontent.com/22488593/174020221-4b0f00a8-8800-4857-a9f9-c3fc7fc0c5d8.png)
  * 사람은 '이름', '성별', '나이'라는 상태를 가지고   
  '먹기', '걷기', '말하기'라는 행동을 할 수 있음
  * 이를 코드로 바꾸면
  ```java
  public class Human
  {
    private string name;
    private int sex;
    private int age;
    
    public void eat();
    public void walk();
    public void talk();
  }
  
  Human student = new Human();
  Human teacher = new Human();
  ```
  * 상태는 클래스의 멤버 변수가 되고
  * 행동은 클래스의 멤버 함수가 됨
  * 여기서는 Human이라는 객체를 만들어 줄 꺼임
  * 클래스는 Human객체의 blueprint라고 보면 됨
  * student와 teacher은 서로 다르지만 사람이라는 공통된 특성을 지님
    * 각각 new Human()을 해줌으로써 특성이 다른 두 사람이 만들어진다
    * new 해주는 걸 인스턴스화 해준다고 함
### 1.3. 복잡해진 OOP
* 무언가를 만들 때는 단순한 부분은 최대한 단순하게 만들고 복잡해야만 하는 부분만 복잡하게 만들어야 함
* 일부 프로그래머들이 단순했던 개체지향 개념을 쓸데없이 복잡하게 만들기 시작 함
  * 일부 개체지향 분석과 디자인(OOAD)
  * 일부 디자인 패턴들
#### 1.3.1. 지양해야될 개체지향 개념 예시
![image](https://user-images.githubusercontent.com/22488593/174023663-981c262e-b916-44c4-983c-c21af161c263.png)
* 개체 B의 숫자를 증가시키고 싶으면 어떻게 해야할까?
##### 1.3.1.1. 복잡한 방법
* 호출자라는 다른 개체를 만듦
  * '명령'이라는 멤버와 '명령 추가', '명령 수행' 두 가지의 함수만 가지고 있음
* '증가명령'이라는 또 다른 개체를 생성 
  * '개체 B'라는 멤버와 '실행'이라는 함수를 가짊
![image](https://user-images.githubusercontent.com/22488593/174024519-9de4ebba-592f-4149-a7b3-3457bb7c610a.png)
* 호출자 개체의 '멤버'에 '증가명령'개체를 '명령 추가'로 추가해 줌
* 그리고 '명령 수행' 함수를 실행한다
* 그러면 '증가명령'의 '실행' 이라는 함수가 실행 됨
* '실행'은 '개체 B'의 '증가'라는 함수를 호출해 줌 
* 정말 복잡하다
  * 유지보수성과 가독성이 떨어짐
  * 하지만 웹프로그래밍에서 이렇게 해야할 때가 있다
* 옛날에는 오브젝트를 한번 만들어 놓으면 그 오브젝트를 절때 변경하지 말고 이것을 포함한 다른 오브젝트를 만들어 계속 크기를 키워가라는 이야기가 있었음
  * 이미 존재하는 오브젝트를 고치면 버그를 만들 수 있기 때문
  * 근데 요즘은 이렇게 하지 않고 그냥 고친다
##### 1.3.1.2. 직관적인 방법
* 그냥 '개체 B'의 '증가'함수를 호출해주면 된다
![image](https://user-images.githubusercontent.com/22488593/174026464-4fc62c37-1651-4943-b0c7-a09f4a2f14c8.png)
* Vector 클래스를 만들어보자
```c++
  class Vector
  {
    int mX;
    int mY;
  }
```
  * 멤버 변수는 앞에 m을 붙여주는게 c++의 관습
  * 매개변수가 x, y일 때 this.x 를 하지 않고도 구분이 가능함
## 2. 접근 제어자(Access Modifier)
* C++의 기본 접근권한은 private
```c++
 class Vector
  {
    int mX; // private 멤버 변수
    int mY; // private 멤버 변수
  }
```
* Java에서 접근권한 제어 키워드를 생략하면 public도 private도 아님
  * 그 변수는 해당 패키지 내에서 접근 가능
    * Java에서는 friend 키워드가 없어서 이게 생겼다고 함 
### 2.1. C++의 접근 제어자(Access Modifier)
* public
  * 누구나 접근 가능
* protected
  * 자식 클래스에서 접근 가능
* private
  * 해당 클래스에서만 접근 가능(개체에서가 아님)
    * 내 자식 클래스는 내 나이를 못 보지만, 나와 같은 부모 클래스인 다른 부모는 내 나이를 볼 수 있음 
* 제어자 별로 C++ 멤버들을 그룹 짓는게 특징임
```c++
class SomeClass
{
public:
  int PublicMember;
protected:
  int mProtectedMember;
private:
  int mPrivateMember1;
  int mPrivateMember2;
}
```
## 3. 개체 생성, 스택/힙
* Java의 개체생성
 ```Java
 // 스택 메모리에 개체생성 불가능

 // 힙(heap) 메모리에 만들기 (느림)
 Vector a = new Vector();
 ```
 * 
* C++의 개체생성
 ```c++
 // 스택 메모리에 만들기 (빠름)
 Vector a;
 
 // 힙 메모리에 만들기 (느림)
 Vector* b = new Vector();
 ```
 * 힙 메모리에 만들면 포인터에 저장해야한다
### 3.1 스택에 개체 생성
```c++
Vector a; 
```
![image](https://user-images.githubusercontent.com/22488593/174066168-fec69096-0841-41b9-95bb-2e31c94c6453.png)
* mX, mY 각각 4바이트로 스택에 8바이트를 차지한다
### 3.2 힙에 개체 생성
```c++
Vector* b = new Vector();
```
![image](https://user-images.githubusercontent.com/22488593/174066474-1934a895-fdd4-4ace-b06b-e1d8980120bf.png)
![image](https://user-images.githubusercontent.com/22488593/174066519-2dff9b08-a247-424e-96a6-16249a44b329.png)
* 힙 메모리에 8바이트가 할당되고 스택에는 그것의 주소가 담긴 포인터가 있음
 * 그림에서 스택은 힙 메모리 주소 5120를 갖고 있다
### 3.3 스택
* 미리 예약된 로컬 메모리 공간
  * 컴파일 옵션으로 스택 크기를 정해줄 수 있음
  * 보통 1MB 이하로 함
  * exe파일을 실행시키면 이 1MB 메모리를 할당 해주고 스택으로 사용하는 것  
* 함수 호출과 반환이 이 메모리에서 일어남
  * A함수를 호출하면 A함수범위만큼 메모리를 차지함
  * A함수가 B함수를 호출하면 A함수범위 위에 B함수가 메모리를 차지함
  * B함수의 호출이 끝나면 B함수범위를 없앰(반환함)
  * A함수의 호출이 끝나도 A함수범위만큼 없어지고 밑으로 내려간다
  * 즉, 함수가 호출될때마다 스택에 쌓이고 반환되면 스택에서 제거됨
* 단순히 스택 포인터를 옮김
  * 메모리를 할당 및 해제할 필요가 없음
  * 스택에서 요소를 제거하려면 일일이 지울 필요 없이 스택 포인터만 아래로 내리면 됨
  * 변수와 매개변수를 위해 필요한 크기는 컴파일 도중에 알 수 있음
  * 스택에 힙보다 빠른 이유임   
* 스택에 큰 개체를 많이 넣으면
  * 스택 오버플로우(overflow)가 발생할 수 있음
* 성능이 느려 질 수도 있음
   * 우리가 스택 크기를 1MB로 잡는다 하면 그것을 다쓰고있지 않는이상 그 1MB전체가 메모리에 들어가 있지 않다
   * 쓰는 부분만 메모리에 들어가 있고 나머지는 하드웨어에 스왑파일로 남아 있다
     * 페이징 기법
   * 나중에 메모리 전체를 사용할 때 그것을 불러오는데 성능이 느려질 수 있다
     * OS의 문제
### 3.4. 힙
* 컴파일 때 컴파일러가 알고 있는 메모리 공간이 아님
* 프로그램이 실행될 때 OS가 제공하는 방대한 메모리 공간
  * OS가 달라질 수 있고 하드웨어 즉 메모리 크기가 달라질 수도 있다
* 비어 있고 연속된 메모리 블록을 찾아야 함
  * 메모리 전체를 다 둘러봐야해서 느리다
* 프로그래머가 메모리를 직접 할당 및 해제해야 함
  * 컴파일러가 힙 메모리를 얼만큼 할당했는지 알 길이 없어서
  * 해제 안하면 메모리 누수 발생
### 3.5. 어디서 힙/스택을 쓸까
* 기본적으로 스택을 쓰는게 좋음
  * 오브젝트의 크기가 충분히 작고 어떤 범위 안에서만 쓸 때 
* 힙을 쓰면 좋은 경우는 
  * 실행중에 새로만드는 일이 많을 때
  * 한 함수 안에서 안끝나고 다른함수로 전달하는 일이 많을 때
  * 반환하는 오브젝트가 너무 클 때 힙에 오브젝트를 만들어 그 주소만 반환하면 됨
    * 큰 오브젝트를 복사해서 반환하는 것보다 낫다
### 3.6. 스택과 힙을 메모리에서 다시 살펴보기

## 4. 개체 배열 생성, 개체 소멸
## 5. 멤버 변수 초기화
## 6. new/delete와 malloc()/free()의 차이
## 7. 생성자(Constructor), 초기화 리스트(Initializer List)
## 8. 기본 생성자, 컴파일러가 하는 일
## 9. 생성자 오버로딩(Overloading), 소멸자(Destructor)
## 10. const 멤버 함수
## 11. 구조체(Struct) vs 클래스(Class)
